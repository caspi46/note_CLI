use clap::{Parser, Subcommand};
use std::fs::File;
use std::io::BufReader;
use std::path::Path; 
use std::io::prelude::*; 


// helper functions 

pub fn format_dates (date: Option<(u32, u32, u32)>) -> String {
    match date {
            Some((year, month, day)) => format!("{}/{}/{}", month, day, year),
            None => format!(""),
    }
}

// Plan CLI 
#[derive(Parser)] 
#[command(name = "tasker", version, about = "A CLI task manager")]
pub struct Plan {
    #[command(subcommand)]
    pub command: Commands
}

impl Plan {
    pub fn add(&self, new_note: &String, start: Option<(u32, u32, u32)>, due: Option<(u32, u32, u32)>) {
        let note = Entry::new(String::from(new_note), start, due); 
        note.add_result();
    }

    pub fn help_inst(&self) {
        println!("You need help?")
    }
}

// Commands 
#[derive(Subcommand)]
pub enum Commands {
    Add {
       #[arg(help = "New note name")]
        new_note: String, 
        start: String, 
        due: String, 
    }, 

    Rm {
        #[arg(help = "Remove note if exists")]
        note: String, 
    }

    // Features: 
    // edit 
    // view progress 
    // 

    // help is automatically generated by Clap 
    // version as well 
}

// Entry (Note Object) 
pub struct Entry {
    pub name: String, 
    pub start: Option<(u32, u32, u32)>,
    pub due: Option<(u32, u32, u32)>,
}

impl Entry {
    pub fn new(name: String, start: Option<(u32, u32, u32)>, due: Option<(u32, u32, u32)>,) -> Self {
        Self {
            name,
            start, 
            due,
        }
    }
    pub fn add_result(&self) {
        let start_format = format_dates(self.start); 
        let due_format = format_dates(self.due); 
        println!("New note: {}\nStart date: {}\nDue date: {}", self.name, start_format, due_format); 
    }
}

// Notes : handle the entire notes 
pub struct Notes {
    pub notes : Vec<String>, 
    pub note_path : std::path::PathBuf,  // if possible backup file 
    pub note_bak : String, 
}

impl Notes {
    pub fn new() -> Result<Self, std::io::Error> {
        let notes = Vec::new(); 
        let note_path = std::path::PathBuf::from(
                std::env::var_os("OUT_DIR")
                    .ok_or_else(|| std::io::ErrorKind::NotFound)?); 
        let note_bak = String::from("");

        Ok(Self {notes, note_path, note_bak })

        // TODO: create/find the plan file that contains the list of plans 
        
    }
}

